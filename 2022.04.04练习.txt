//删除链表中的节点
/*
请编写一个函数，用于删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问要被删除的节点 。

题目数据保证需要删除的节点不是末尾节点 。
*/

/*
删除链表中的节点的常见的方法是定位到待删除节点的上一个节点，修改上一个节点的 next 指针，使其指向待删除节点的下一个节点，即可完成删除操作。

这道题中，传入的参数 node 为要被删除的节点，无法定位到该节点的上一个节点。
注意到要被删除的节点不是链表的末尾节点，因此 node.next 不为空，可以通过对 node 和 node.next 进行操作实现删除节点。

在给定节点 node 的情况下，可以通过修改 node 的 next 指针的指向，删除 node 的下一个节点。
但是题目要求删除 node，为了达到删除 node 的效果，只要在删除节点之前，将 node 的节点值修改为 node.next 的节点值即可。

例如，给定链表 4→5→1→9，要被删除的节点是 5，即链表中的第 2 个节点。可以通过如下两步操作实现删除节点的操作。

将第 2 个节点的值修改为第 3 个节点的值，即将节点 5 的值修改为 1，此时链表如下：
4→1→1→9

删除第 3 个节点，此时链表如下：
4→1→9
*/

//class Solution
//{
//public:
//    void deleteNode(ListNode* node)
//    {
//        node->val = node->next->val;
//        node->next = node->next->next;
//    }
//};









//合并两个有序数组
/*
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，
后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
*/

//先合并后排序
//#include<iostream>
//#include<vector>
//#include<algorithm>
//using namespace std;
//class Solution
//{
//public:
//    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
//    {
//        vector<int>v;
//        for (int i = 0; i < max(m, n); ++i)
//        {
//            if (i < m)
//            {
//                v.push_back(nums1[i]);
//            }
//            if (i < n)
//            {
//                v.push_back(nums2[i]);
//            }
//        }
//        nums1.clear();
//        for (vector<int>::iterator it =v.begin();it != v.end();++it)
//        {
//            nums1.push_back(*it);
//        }
//        sort(nums1.begin(), nums1.end());
//    }
//};


//时间优化版
//#include<iostream>
//#include<vector>
//#include<algorithm>
//using namespace std;
//class Solution
//{
//public:
//    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
//    {
//        for (int i = 0; i != n; ++i)
//        {
//            nums1[m + i] = nums2[i];
//        }
//        sort(nums1.begin(), nums1.end());
//    }
//};

//双指针
/*
将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中
为两个数组分别设置 p_1与 p_2来作为队列的头部指针
*/

//#include<iostream>
//#include<vector>
//using namespace std;
//class Solution
//{
//public:
//    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
//    {
//        int p1 = 0, p2 = 0;
//        int* sorted = new (int [m + n]);
//        if (sorted == NULL)
//        {
//            return;
//        }
//        int cur;
//        while (p1 < m || p2 < n)
//        {
//            if (p1 == m)
//            {
//                cur = nums2[p2++];
//            }
//            else if (p2 == n)
//            {
//                cur = nums1[p1++];
//            }
//            else if (nums1[p1] < nums2[p2])
//            {
//                cur = nums1[p1++];
//            }
//            else
//            {
//                cur = nums2[p2++];
//            }
//            sorted[p1 + p2 - 1] = cur;
//        }
//        for (int i = 0; i != m + n; ++i)
//        {
//            nums1[i] = sorted[i];
//        }
//        delete[]sorted;
//    }
//};