


//单向链表
//#include<stdio.h>
//#include<string.h>
//#include<stdlib.h>
//struct LinkNode//结点结构体
//{
//	//数据域
//	void* data;
//	//指针域
//	struct LinkNode* next;
//};
//struct LList//链表结构体
//{
//	struct LinkNode pHeader;//链表头——不存放数据
//	int m_size;//链表长度
//};
//typedef void* LinkList;//将void*改名为LinkList(方便用户使用，避免用户恶意操作)
////初始化链表
//LinkList init_LinkList()
//{
//	struct LList* mylist = malloc(sizeof(struct LList));
//	if (mylist == NULL)
//	{
//		return NULL;
//	}
//	mylist->pHeader.next = NULL;
//	mylist->pHeader.data = NULL;
//	mylist->m_size = 0;
//	return mylist;
//}
////实现链表的插入
//void insert_LinkList(LinkList list, int pos, void* data)
//{
//	struct LList* mylist = list;
//	if (list == NULL || data == NULL)
//	{
//		return;
//	}
//	if (pos < 0 || pos > mylist->m_size)//只有转换为strcut LList*才可访问结构体属性
//	{
//		pos = mylist->m_size;//位置无效则尾插
//	}
//	//找到插入结点的前驱结点
//	struct LinkNode* pCurrent = &mylist->pHeader;
//	for (int i = 0; i < pos; i++)
//	{
//		pCurrent = pCurrent->next;
//	}//pCurrent找到找插入位置的前驱结点
//	struct LinkNode* newNode = malloc(sizeof(struct LinkNode));//创建新结点
//	if (newNode == NULL)
//	{
//		return;
//	}
//	newNode->data = data;
//	//建立结点关系
//	newNode->next = pCurrent->next;
//	pCurrent->next = newNode;
//	mylist->m_size++;
//}
////实现链表的遍历
//void for_each_LinkList(LinkList list,void (*myPrint)(void*))
//{
//	struct LList* mylist = list;
//	if (list == NULL)
//	{
//		return;
//	}
//	struct LinkNode* pCurrent = mylist->pHeader.next;
//	for (int i = 0; i < mylist->m_size; i++)
//	{
//		myPrint(pCurrent->data);
//		pCurrent = pCurrent->next;
//	}
//}
////实现链表按位置删除元素
//void removebyPos_LinkList(LinkList list, int pos)
//{
//	struct LList* mylist = list;
//	if (list == NULL||pos<0||pos>mylist->m_size-1)
//	{
//		return;
//	}
//	struct LinkNode* pCurrent = &mylist->pHeader;
//	for (int i = 0; i < pos; i++)//找到前驱结点
//	{
//		pCurrent = pCurrent->next;
//	}
//	struct LinkNode* pDel = pCurrent->next;//记录待删除的结点
//	pCurrent->next = pDel->next;
//	free(pDel);
//	pDel = NULL;
//	mylist->m_size--;//更新链表长度
//}
////实现链表按值删除元素
//void removebyValue_LinkList(LinkList list, void* data,int (*myCompare)(void*,void*))
//{
//	struct LList* mylist = list;
//	if (list == NULL || data == NULL)
//	{
//		return;
//	}
//	//创建两个辅助指针
//	struct LinkNode* pPrev = &mylist->pHeader;
//	struct LinkNode* pCurrenr = mylist->pHeader.next;
//	for (int i = 0; i < mylist->m_size; i++)
//	{
//		if (myCompare(pCurrenr->data, data))
//		{
//			pPrev->next = pCurrenr->next;
//			free(pCurrenr);
//			pCurrenr = NULL;
//			mylist->m_size--;
//			break;
//		}
//		pPrev = pPrev->next;
//		pCurrenr = pCurrenr->next;
//	}
//}
////清空链表
//void clear_LinkList(LinkList list)
//{
//	struct LList* mylist = list;
//	if (list == NULL)
//	{
//		return;
//	}
//	struct LinkNode* pCurrent = mylist->pHeader.next;
//	for (int i = 0; i < mylist->m_size; i++)
//	{
//		struct LinkNode* pNext = pCurrent->next;
//		free(pCurrent);
//		pCurrent = pNext;
//	}
//	mylist->pHeader.next = NULL;
//	mylist->m_size = 0;
//}
////实现返回链表的长度
//int size_LinkList(LinkList list)
//{
//	if (list == NULL)
//	{
//		return -1;
//	}
//	struct LList* mylist = list;
//	return mylist->m_size;
//}
////实现销毁链表
//void destroy_LinkList(LinkList list)
//{
//	if (list == NULL)
//	{
//		return;
//	}
//	clear_LinkList(list);
//	free(list);
//	list = NULL;
//}
//
//
//
////测试
//struct Person
//{
//	char name[64];
//	int age;
//};
//void myPrintPerson(void* data)
//{
//	struct Person* p = data;
//	printf("姓名:%s\n", p->name);
//	printf("年龄:%d\n", p->age);
//}
//int compare(void* p1, void* p2)
//{
//	struct Person* P1 = p1;
//	struct Person* P2 = p2;
//	return (P1->age == P2->age) && strcmp(P1->name, P2->name) == 0;
//}
//int main()
//{
//	LinkList list = init_LinkList();
//	struct Person p1 = { "aaa",1 };
//	struct Person p2 = { "bbb",2 };
//	struct Person p3 = { "ccc",3 };
//	struct Person p4 = { "ddd",4 };
//	struct Person p5 = { "eee",5 };
//	struct Person p6 = { "fff",6 };
//	struct Person p7 = { "ggg",7 };
//
//	insert_LinkList(list, -1, &p1);
//	insert_LinkList(list, 2, &p2);
//	insert_LinkList(list, 3, &p3);
//	insert_LinkList(list, 4, &p4);
//	insert_LinkList(list, 5, &p5);
//	insert_LinkList(list, 6, &p6);
//	insert_LinkList(list, 7, &p7);
//
//	printf("当前链表的长度为:%d\n", size_LinkList(list));
//	removebyPos_LinkList(list, 0);
//	removebyValue_LinkList(list, &p2,compare);
//	printf("当前链表的长度为:%d\n", size_LinkList(list));
//
//	for_each_LinkList(list, myPrintPerson);
//	clear_LinkList(list);
//	printf("当前链表的长度为:%d\n", size_LinkList(list));
//	destroy_LinkList(list);
//	list = NULL;
//	return 0;
//}


























//单向链表企业版
//#include<stdlib.h>
//#include<stdio.h>
//struct LinkNode
//{
//	struct LinkNode* next;//只维护一个指针域
//};
//struct LList
//{
//	struct LinkNode pHedder;
//	int m_size;
//};
//typedef void* LinkList;
////初始化链表
//LinkList init_LinkList()
//{
//	struct LList* mylist = malloc(sizeof(struct LList));
//	if (mylist == NULL)
//	{
//		return NULL;
//	}
//	mylist->pHedder.next = NULL;
//	mylist->m_size = 0;
//	return mylist;
//}
////实现插入
//void insert_LinkList(LinkList list, int pos, void* data)
//{
//	struct LList* mylist = list;
//	if (list == NULL || data == NULL)
//	{
//		return;
//	}
//	if (pos<0 || pos>mylist->m_size)
//	{
//		pos = mylist->m_size;//无效位置变为尾插
//	}
//	//用户数据前四个字节由我们使用
//	struct LinkNode* myNode = data;//struct LinkNode*大小为四个字节，转换后我们只能使用前四个字节
//	//找到前驱结点
//	struct LinkNode* pCurrent = &mylist->pHedder;
//	for (int i = 0; i < pos; i++)
//	{
//		pCurrent = pCurrent->next;
//	}
//	//更改指针指向
//	myNode->next = pCurrent->next;
//	pCurrent->next = myNode;
//	mylist->m_size++;
//}
////实现遍历
//void for_each_LinkList(LinkList list,void(*myPrint)(void*))
//{
//	struct LList* mylist = list;
//	if (list == NULL)
//	{
//		return;
//	}
//	struct LinkNode* myNode = mylist->pHedder.next;
//	for (int i = 0; i < mylist->m_size;i++)
//	{
//		myPrint(myNode);
//		myNode = myNode->next;
//	}
//}
////实现按位置删除
//void removebyPos_LinkList(LinkList list, int pos)
//{
//	struct LList* mylist = list;
//	if (list == NULL)
//	{
//		return;
//	}
//	if (pos<0 || pos>mylist->m_size - 1)
//	{
//		return;
//	}
//	//找到待删除结点的前驱
//	struct LinkNode* pCurrent = &mylist->pHedder;
//	for (int i = 0; i < pos; i++)
//	{
//		pCurrent = pCurrent->next;
//	}
//	struct LinkNode* pDel = pCurrent->next;//记录待删除结点
//	pCurrent->next = pDel->next;
//	mylist->m_size--;
//	//数据由用户管理的，所以由用户管理释放
//}
////销毁数组
//void destroy_LinkList(LinkList list)
//{
//	if (list == NULL)
//	{
//		return;
//	}
//	free(list);//直接释放，数据由用户管理
//	list = NULL;
//}
//
//
//
//
////测试
//struct Person
//{
//	void* node;//用户预留前四个字节交予链表使用
//	char name[64];
//	int age;
//};
//void myPrintPerson(void* data)
//{
//	struct Person* p = data;//由struct LinkNode*转换为struct Person*即可查询到数据部分
//	printf("姓名:%s\n", p->name);
//	printf("年龄:%d\n", p->age);
//}
//int main()
//{
//	LinkList list = init_LinkList();
//	struct Person p1 = { NULL,"aaa",1 };
//	struct Person p2 = { NULL,"bbb",2 };
//	struct Person p3 = { NULL,"ccc",3 };
//	struct Person p4 = { NULL,"ddd",4 };
//	struct Person p5 = { NULL,"eee",5 };
//	struct Person p6 = { NULL,"fff",6 };
//	struct Person p7 = { NULL,"ggg",7 };
//
//	insert_LinkList(list, -1, &p1);
//	insert_LinkList(list, 2, &p2);
//	insert_LinkList(list, 3, &p3);
//	insert_LinkList(list, 4, &p4);
//	insert_LinkList(list, 5, &p5);
//	insert_LinkList(list, 6, &p6);
//	insert_LinkList(list, 7, &p7);
//
//	removebyPos_LinkList(list, 0);
//	for_each_LinkList(list, myPrintPerson);
//	destroy_LinkList(list);
//	list = NULL;
//	return 0;
//}


