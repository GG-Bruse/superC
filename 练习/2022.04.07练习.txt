/*
给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。
*/
//#include<iostream>
//#include<string>
//using namespace std;
////class Solution
////{
////public:
////    string toLowerCase(string s)
////    {
////        for (string::iterator it = s.begin(); it != s.end(); ++it)
////        {
////            if (*it >= 65 && *it <= 90)
////            {
////                *it += 32;
////            }
////        }
////        return s;
////    }
////};
//class Solution
//{
//public:
//    string toLowerCase(string s)
//    {
//        for (string::iterator it = s.begin(); it != s.end(); ++it)
//        {
//            *it = tolower(*it);
//        }
//        return s;
//    }
//};
//int main()
//{
//    Solution sol;
//    string str = "LOVELY";
//    cout<<sol.toLowerCase(str);
//	return 0;
//}










/*
给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
*/

/*
反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串。
*/
//#include<iostream>
//#include<string>
//using namespace std;
//class Solution
//{
//public:
//    string reverseStr(string s, int k)
//    {
//        int n = s.length();
//        for (int i = 0; i < n; i += 2 * k)
//        {
//            reverse(s.begin() + i, s.begin() + min(i + k, n));
//        }
//        return s;
//    }
//};
//int main()
//{
//    string str = "abcdefg";
//    Solution s;
//    cout<<s.reverseStr(str, 2);
//	return 0;
//}