                                                         //初识C++

//面向对象三大特性:
//封装、继承、多态

//#include<iostream>//包含标准输入输出流
//using namespace std;//命名空间 
////对头文件的又一次细分，优化编译，用不到就不包含
//int main()
//{
//	//c out(输出)、c in(输入)
//	cout << "bjy is the best handsome.\n" << "hello world!\n";
//	cout << 3.14 << 'A' << "abcd" << 10;//泛型:自动推理数据类型
//	return 0;
//}


////#include<stdlib.h>
//#include<cstdlib>//C++风格
//using namespace std;
//int main()
//{
//    //char str[20] = "tasklist &pause";
//    char str[20]{ "tasklist &pause" };//C++风格
//    system(str);
//    return 0;
//}


//#include<iostream>
//using namespace std;
//int main()
//{
//    char ch;
//    double db;
//    int num;
//    cin >> num>>db >> ch;
//    cout << num << db << ch << endl;//endl结束并换行
//    //cin cout 都遵循泛型
//    return 0;
//}














                                                       //双冒号作用域运算符
//::代表作用域 
/*
若前面什么都不添加，则代表全局作用域
若前面有内容，则代表内容的作用域
*/
//#include<iostream>
//using namespace std;
//int atk = 1000;
//void test()
//{
//    int atk = 2000;
//    cout << "atk=" << atk << endl;//2000
//    cout << "全局atk=" << ::atk << endl;//1000
//}
//int main()
//{
//    test();
//    return 0;
//}















                                                       //namespace命名空间
//1.解决名称冲突
//#include<iostream>
//using namespace std;
//namespace kingglory
//{
//    void goatk();
//}
//namespace LOL
//{
//    void goatk();
//}
//void kingglory::goatk()
//{
//    cout << "王者荣耀攻击实现" << endl;
//}
//void LOL::goatk()
//{
//    cout << "LOL攻击实现" << endl;
//}
//int main()
//{
//    kingglory::goatk();//王者荣耀攻击实现
//    LOL::goatk();//LOL攻击实现
//    return 0;
//}



//2.命名空间可以存放变量、函数、结构体、类等内容
//#include<iostream>
//using namespace std;
//namespace A
//{
//    int a;
//    void func();
//    struct S {};
//    class animal{};
//}
//int main()
//{
//    return 0;
//}



//3.命名空间必须声明在全局作用域下


//4.命名空间可以嵌套
//#include<iostream>
//using namespace std;
//namespace A
//{
//    int a = 10;
//    namespace B
//    {
//        int a = 20;
//    }
//}
//int main()
//{
//    cout << "A空间下的a=" << A::a << endl;
//    cout << "B空间下的a=" << A::B::a << endl;
//    return 0;
//}



//5.命名空间是开放的，可以随时添加新成员
//#include<iostream>
//using namespace std;
//namespace A
//{
//    int a = 100;
//}
//namespace A
//{
//    int b = 100;
//}
////两个命名空间进行合并
//int main()
//{
//    cout << "A空间下的a=" << A::a << endl;
//    cout << "A空间下的b=" << A::b << endl;
//    return 0;
//}



//6.命名空间可以是匿名的
//#include<iostream>
//using namespace std;
//namespace
////当命名空间为匿名的,其中变量默认为静态变量,相当于static int a =1;static int b=2;
//{
//    int a = 1;
//    int b = 2;
//}
//int main()
//{
//    cout << a << endl;
//    cout << ::b << endl;
//    return 0;
//}



//7.命名空间可以有多个名字
//#include<iostream>
//using namespace std;
//namespace verylong
//{
//    int a = 10;
//}
//int main()
//{
//    namespace veryshort = verylong;
//    cout << verylong::a << endl;
//    cout << veryshort::a << endl;
//    return 0;
//}
















                                                           //using

//using声明
//声明的命名空间不可有与局部变量相同名字的变量
//#include<iostream>
//using namespace std;
//namespace A
//{
//    int suwukongID = 1;
//}
//int main()
//{
//    //using声明
//    using A::suwukongID;//声明需要使用空间A的suwukongID变量
//    cout << suwukongID << endl;
//    return 0;
//}



//using编译指令
//#include<iostream>
//using namespace std;
//namespace A
//{
//    int suwukongID = 1;
//}
//void test()
//{
//    int suwukongID = 2;
//    using namespace A;//相当于打开命名空间A
//    cout << A::suwukongID << endl;//1
//    cout << suwukongID << endl;//2 若没有具体指定，局部变量优先于using指令
//}
//int main()
//{
//    test();
//    return 0;
//}



//起别名
//#include<iostream>
//#include<type_traits>
//using namespace std;
//using m_int = int;
//int main()
//{
//    //判断2个类型是否一致，若是返回真，否则为假
//    cout << is_same<int, m_int>::value << endl;//模板
//    return 0;
//}
















                                                     //C++对C语言的扩展与增强
//1.全局变量的检测增强


//2.函数的检测增强(函数类型、返回值、形参、实参等)


//3.类型转换检测增强


//4.struct增强
/*
C语言中的结构体不允许有函数，而C++中的结构体中可以有函数
C语言中创建结构体变量时，必须加关键字struct;而C++中可以简化关键字struct
*/


//5.bool类型的扩展
/*
C语言中不存在bool类型，而C++中存在
bool类型 true——真(1) false——假(0) 大小为1个字节
*/
//#include<iostream>
//using namespace std;
//int main()
//{
//    bool flag1 = true;
//    bool flag2 = 100;
//    cout << flag1 << endl;//1
//    cout << flag2 << endl;//将所有非0的数都转换为1
//    cout << sizeof(bool) << endl;
//    return 0;
//}


//6.三目运算符的增强
//C语言中的三目运算符返回的是值，而C++中返回的是变量
//#include<iostream>
//using namespace std;
//int main()
//{
//    int a = 10;
//    int b = 20;
//    cout << (a > b ? a : b) << endl;//20
//    a > b ? a : b = 100;//C语言中不允许这种语句
//    cout << a << endl;//10
//    cout << b << endl;//100
//    return 0;
//}


//7.const增强
/*
const修饰的变量都不可直接修改
(1)C语言中，const修饰的全局变量不可以通过指针修改，其受到常量区的保护。
  const修饰的局部变量可以通过指针修改，其分配在栈上，为具有常属性的变量。
(2)C++中，const修饰的全局变量不可以通过指针修改，其受到常量区的保护。
   const修饰局部变量不可以通过指针修改，相当于常量，甚至可进行数组的初始化。
*/
/*
只要对变量本身进行了内存分配，就可以通过指针找到并修改
(1)对const修饰的变量取地址，会拷贝备份并为备份分配临时内存，所以用指针无法修改。
(2)使用普通变量对const修饰的变量进行初始化，可以使用指针进行修改。
(3)对于const修饰自定义数据类型变量，可以使用指针进行修改。
*/
/*
C语言中，const修饰的全局变量默认是外部链接属性，声明(extern)后可以使用。
C++中，const修饰的全局变量默认是内部链接属性，可以在变量前加上extern提高其作用域。
*/













                                                               //引用
//引用的本质在C++内部实现是一个指针

//引用的目的:起别名(a和b操作同一块内存)   
//引用必须初始化赋值且一旦初始化后就不能指向别的内存
//#include<iostream>
//using namespace std;
//int main()
//{
//    int a = 10;
//    int& b = a;
//    b = 100;
//    cout << "a = " << b << endl;
//    return 0;
//}


//对数组建立引用
//#include<iostream>
//using namespace std;
//int main()
//{
//    int arr[10] = { 0 };
//    int(&brr)[10] = arr;
//    int i;
//    for (i = 0; i < 10; i++)
//    {
//        arr[i] = i;
//    }
//    for (i = 0; i < 10; i++)
//    {
//        cout << brr[i] << " ";
//    }
//    return 0;
//}

/*
引用的注意事项:
1.引用的必须是一块合法的内存空间。
2.不要返回局部、临时变量的引用(内存空间会被释放)
3.若函数返回的是引用，那么函数的调用可以作为左值
*/



//指针的引用
//若要使用高级指针，可以直接使用同级指针的引用进行代替，从而简化指针的用法
//#include<iostream>
//using namespace std;
//struct Person
//{
//    int age;
//};
//void test(Person* &pp)
//{
//    pp = (Person*)malloc(sizeof(Person));
//    if (pp != NULL)
//    {
//        pp->age = 18;
//    }
//}
//int main()
//{
//    Person* p = NULL;
//    test(p);
//    cout << p->age << endl;
//    free(p);
//    p = NULL;
//    return 0;
//}



//常量的引用
//#include<iostream>
//using namespace std;
//int main()
//{
//    //int& ref = 10;
//    //不允许,引用的必须是一块合法的内存空间
//    const int& ref = 10;
//    //加了const后，相当于int temp=10;const int& ref=temp;(可以通过指针修改)
//    return 0;
//}

//#include<iostream>
//using namespace std;
//void test(const int& as)//修饰形参，防止由于误操作导致变量的值被修改
//{
//    cout << as << endl;
//}
//int main()
//{
//    int a = 10;
//    test(a);
//    return 0;
//}












                                                       //参数的传递方式

//1.值传递(不改变原始值)
//#include<iostream>
//using namespace std;
//void Swap(int a,int b)
//{
//    int temp = a;
//    a = b;
//    b = temp;
//}
//int main()
//{
//    int a = 10;
//    int b = 20;
//    Swap(a, b);
//    cout << "a = " << a << endl;
//    cout << "b = " << b << endl;
//    return 0;
//}


//址传递
//#include<iostream>
//using namespace std;
//void Swap(int* pa, int* pb)
//{
//    int temp = *pa;
//    *pa = *pb;
//    *pb = temp;
//}
//int main()
//{
//    int a = 10;
//    int b = 20;
//    Swap(&a, &b);
//    cout << "a = " << a << endl;
//    cout << "b = " << b << endl;
//    return 0;
//}


//引用传递
//#include<iostream>
//using namespace std;
//void Swap(int& a,int& b)
//{
//    int temp = a;
//    a = b;
//    b = temp;
//}
//int main()
//{
//    int a = 10;
//    int b = 20;
//    Swap(a, b);
//    cout << "a = " << a << endl;
//    cout << "b = " << b << endl;
//    return 0;
//}

















                                                         //内联函数(inline)
/*
内联函数本质上还是一个真正的函数，其具有普通函数的所有行为。

内联函数和普通函数的区别在于：
当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，
就像整个函数体在调用处被重写了一遍一样。
有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。
使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间

优点:解决了宏的缺陷，同时具有宏的优势，以空间换时间


注意:
1.函数体和声明必须结合在一起，否则编译器还会将其作为普通函数对待
2.为定义内联函数，通常必须加上一个inline关键字，但在类内部定义内联函数时不是必须的，任何在类内部定义的函数默认为内联函数
3.C++内联编译有一些限制，某些情况下编译器可能考虑不会将函数进行内联编译:
    (1)不能存在任何形式的循环语句
    (2)不能存在过多的条件判断语句
    (3)函数体不能过于庞大(没有明确标准)
    (4)不能对函数进行取址操作
4.内联仅仅是给编译器的一个建议，编译器不一定会接受。若你没有将函数声明为内联函数，编译器也可能将该函数看作内联函数
*/



//使用方法与普通函数基本相同
//#include<iostream>
//#include<string>
//using namespace std;
//inline int func(int,int);//声明
//inline int func(int a,int b)//定义
//{
//    return a + b;
//}
//int main()
//{
//    int a = 10;
//    int b = 20;
//    int ret = func(a, b);
//    cout << ret << endl;
//    return 0;
//}












                                                      //函数的默认参数和占位参数

//默认参数(在形参中赋值)
//函数的声明和定义中有且只有一个提供默认参数
//#include<iostream>
//using namespace std;
//int fun(int a = 10, int b = 10)
//{
//    return a + b;
//}
//int main()
//{
//    cout << fun() << endl;//20
//    cout << fun(20,10) << endl;//30(一旦传参，就不取用默认参数)
//    return 0;
//}



//占位参数(只写一个类型进行占位，调用时必须传入占位值)
//占位参数也可以有默认值
//#include<iostream>
//using namespace std;
//void fun(int a,int)
//{}
//int main()
//{
//    fun(10,20);
//    return 0;
//}

















                                                             //函数重载
/*
在传统C语言中，程序中不允许出现同名的函数。而在C++中可以出现同名函数，这种现象被称为函数重载。
函数重载的条件:
(1)同一作用域下并且名称相同(否则没必要重载)
(2)参数个数不同
(3)参数类型不同
(4)参数顺序不同
*/
/*
注意事项:
1.函数的返回值不能作为重载条件
2.加const和不加const的引用也可以作为重载条件
3.函数重载遇到默认参数时要避免二义性
*/

//#include<iostream>
//using namespace std;
//void A()
//{
//    cout << "函数A()调用" << endl;
//}
//void A(int a)
//{
//    cout << "函数A(int a)调用" << endl;
//}
//int main()
//{
//    A(1);//函数A(int a)调用
//    A();//函数A()调用
//    return 0;
//}

//#include<iostream>
//using namespace std;
//void A(int& a)
//{
//    cout << "函数A(int& a)调用" << endl;
//}
//void A(const int& a)
//{
//    cout << "函数A(const int& a)调用" << endl;
//}
//int main()
//{
//    int a = 10;
//    A(a);//函数A(int& a)调用
//    A(1);//函数A(const int& a)调用
//    return 0;
//}
















                                                        //extern "C"
/*
在C++中存在函数重载，会修饰函数名。若函数定义存在于C语言文件中，C++文件中的main函数无法调用，产生链接失败。

解决:
(1)在main文件中:
extern "C" void show();//告诉编译器对show函数使用C语言的方式链接

(2)在头文件中:
#ifdef __cplusplus
extern "C" {
#enddef
…………
…………
#ifdef __cplusplus
}
#endif
*/

