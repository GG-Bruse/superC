/重复元素1
/*
给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
*/

//#include<iostream>
//#include<vector>
//#include<algorithm>
//using namespace std;
//class Solution
//{
//public:
//    bool containsDuplicate(vector<int>& nums)
//    {
//        sort(nums.begin(), nums.end());
//        for (int i = 1; i < nums.size(); ++i)
//        {
//            if (nums[i - 1] == nums[i])
//            {
//                return true;
//            }
//        }
//        return false;
//    }
//};












//重复元素2
/*
给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。
如果存在，返回 true ；否则，返回 false 。
*/

//效率太低
//#include<iostream>
//#include<vector>
//using namespace std;
//class Solution
//{
//public:
//    bool containsNearbyDuplicate(vector<int>& nums, int k)
//    {
//        for (int i = 0; i < nums.size(); ++i)
//        {
//            for (int j = i; j < nums.size(); ++j)
//            {
//                if (i != j && nums[i] == nums[j] && abs(i-j)<=k)
//                {
//                    return true;
//                }
//            }
//        }
//        return false;
//    }
//};
//int main()
//{
//    vector<int>v;
//    v.push_back(1);
//    v.push_back(2);
//    v.push_back(3);
//    v.push_back(1);
//    Solution s;
//    cout<<s.containsNearbyDuplicate(v, 3);
//	return 0;
//}


/*
方法二：滑动窗口
考虑数组nums 中的每个长度不超过k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过k。
如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 i 和 j 满足 nums[i]=nums[j] 且 ∣i−j∣≤k。
如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。

如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。
从左到右遍历数组nums，当遍历到下标 i 时，具体操作如下：

如果 i>k，则下标 i−k−1 处的元素被移出滑动窗口，因此将nums[i−k−1] 从哈希集合中删除；

判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回true，如果不在哈希集合中则将其加入哈希集合。

当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 false。
*/