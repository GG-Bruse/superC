/*
给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
不使用额外空间且时间复杂度为 O(n)
*/


//#include<iostream>
//#include<vector>
//#include<algorithm>
//using namespace std;
//1.所用时间过长
//class Solution {
//public:
//    vector<int> findDisappearedNumbers(vector<int>& nums)
//    {
//        sort(nums.begin(), nums.end());
//        int size = nums.size();
//        for (vector<int>::iterator it = nums.begin();it!=nums.end()-1;++it)
//        {
//            if (*it == *(it+1))
//            {
//                nums.erase((it+1));
//                it--;
//            }
//        }
//        for (int i = 0; i < size; ++i)
//        {
//            vector<int>::iterator ret = find(nums.begin(), nums.end(), i + 1);
//            if (ret != nums.end())
//            {
//                nums.erase(ret);
//            }
//            else
//            {
//                nums.push_back(i + 1);
//            }
//        }
//        return nums;
//    }
//};
//int main()
//{
//    vector<int>v;
//    Solution s;
//    v.push_back(4);
//    v.push_back(3);
//    v.push_back(2);
//    v.push_back(7);
//    v.push_back(8);
//    v.push_back(2);
//    v.push_back(3);
//    v.push_back(1);
//    s.findDisappearedNumbers(v);
//    for (int i = 0; i < v.size(); ++i)
//    {
//        cout << v[i] << endl;
//    }
//    return 0;
//}

//2
/*
具体来说，遍历 \textit{nums}nums，每遇到一个数 xx，就让 \textit{nums}[x-1]nums[x−1] 增加 nn。由于 \textit{nums}nums 中所有数均在 [1,n][1,n] 中，
增加以后，这些数必然大于 nn。最后我们遍历 \textit{nums}nums，若 \textit{nums}[i]nums[i] 未大于 nn，就说明没有遇到过数 i+1i+1。这样我们就找到了缺失的数字

注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 nn 取模来还原出它本来的值。

即利用下标求解
*/
//class Solution {
//public:
//    vector<int> findDisappearedNumbers(vector<int>& nums) {
//        vector<int> res;
//        if (nums.empty()) return nums;
//        for (int i = 0; i < nums.size(); i++)
//        {
//            int index = (nums[i] - 1) % nums.size();
//            nums[index] += nums.size();
//        }
//        for (int i = 0; i < nums.size(); i++)
//        {
//            if (nums[i] <= nums.size())
//                res.push_back(i + 1);
//        }
//        return res;
//    }
//};