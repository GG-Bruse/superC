
                                                            //类和对象

//初识
/*
类的关键字:class
类中的函数被称为成员函数(或成员方法)
类中的变量被称为成员变量(或成员属性)
通过类创建一个变量(对象),被称为实例化对象
*/
//#include<iostream>
//using namespace std;
//class A
//{
//public:
//    int a;//只有非静态成员变量属于类对象上
//
//    void fun1() {}//成员函数不属于类对象上
//
//    static int b;//静态成员变量不属于类对象上
//
//    static void fun2() {}//静态成员函数不属于类对象上
//
//    double d;//与struct相同也遵循内存对齐
//};
//int main()
//{
//    A a;
//    cout << sizeof(a) << endl;//16
//    return 0;
//}


//空类以及空对象的大小为1字节
//#include<iostream>
//using namespace std;
//class Person
//{};
//int main()
//{
//    Person p;
//    cout << sizeof(Person) << endl;//1
//    cout << sizeof(p) << endl;//1
//    return 0;
//}


//设计一个类，求圆的周长
//#include<iostream>
//using namespace std;
//const float pi = 3.14f;
//class Circle
//{
//public://公共权限
//	float R;
//	void SETR(float r)//设置半径
//	{
//		R = r;
//	}
//	float ZC()//返回周长
//	{
//		return 2 * R * pi;
//	}
//};
//int main()
//{
//	Circle c1;//通过类创建一个对象(实例化对象)
//	c1.SETR(10);//c1.R = 10;
//	cout << "圆的周长为 = " << c1.ZC() << endl;//62.8
//	return 0;
//}



//设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，并且可以显示学生的姓名和学号
//#include<iostream>
//#include<string>
//using namespace std;
//class student
//{
//public:
//    struct S
//    {
//        string name;
//        int ID;
//    }s1;
//    void get()
//    {
//        S* p = &s1;
//        cout << "请输入学生的姓名:";
//        cin >> p->name;
//        cout << "请输入学生的学号:";
//        cin >> p->ID;
//    }
//    void put()
//    {
//        S* p = &s1;
//        cout << p->name << ":" << p->ID << endl;
//    }
//};
//int main()
//{
//    student s;
//    s.get();
//    s.put();
//    return 0;
//}










//类的封装
/*
C++封装理念:
将属性和行为作为一个整体，来表现事物。
将属性和行为加以权限控制
*/
/*
class的默认权限为私有权限
访问权限:
1.public公共权限——类内类外都可以访问成员
2.private私有权限——类内可以访问成员、类外不可访问成员
3.protectd保护权限——类内可以访问成员、类外不可访问成员(子类可以访问父类的protectd权限内容)
*/

/*
建议将成员属性设置为private私有权限
优势:
(1)可以通过在类中编写函数来控制读写
(2)可以在函数中对设置内容加以有效性验证
*/

//#include<iostream>
//#include<string>
//using namespace std;
//class Person
//{
//public:
//    //设置名字
//    int setname(string p)
//    {
//        if (p == "李四")
//        {
//            cout << "该名字已被使用" << endl;
//            return 0;
//        }
//        name = p;
//    }
//    //读取名字
//    string getname()
//    {
//        return name;
//    }
//    //读取年龄
//    int getage()
//    {
//        return age;
//    }
//    //设置
//    void setlover(string a)
//    {
//        lover = a;
//    }
//private:
//    string name = "王五";//可读、可写
//    int age = 18;//可读
//    string lover;//可写
//};
//void test()
//{
//    Person p;
//    //名字
//    p.setname("李四");
//    cout << p.getname() << endl;
//    //年龄
//    cout << p.getage() << endl;
//    //LOVER
//    p.setlover("abcdef");
//}
//int main()
//{
//    test();
//    return 0;
//}



//立方体类设计案例
//分别通过全局函数和成员函数判断两立方体是否相等
//#include<iostream>
//using namespace std;
//class Cube
//{
//public:
//    //设置长宽高
//    void setLWH(int a,int b,int c)
//    {
//        l = a;
//        w = b;
//        h = c;
//    }
//    //获取长宽高
//    int getL()
//    {
//        return l;
//    }
//    int getW()
//    {
//        return w;
//    }
//    int getH()
//    {
//        return h;
//    }
//    //求面积
//    int S()
//    {
//        return 2 * l * w + 2 * l * h + 2 * w * h;
//    }
//    //求体积
//    int V()
//    {
//        return l * w * h;
//    }
//    //判断
//    bool compare(Cube &c)
//    {
//        return ((l == c.getL()) && (w == c.getW()) && (h == c.getH()));  
//    }
//private:
//    int l;//长
//    int w;//宽
//    int h;//高
//};
//bool compareCube(Cube &c1,Cube &c2)
//{
//    return ((c1.getL() == c2.getL()) && (c1.getW() == c2.getW()) && (c1.getH() == c2.getH()));   
//}
//int main()
//{
//    Cube c1, c2;
//    c1.setLWH(10,10,10);
//    c2.setLWH(10, 10, 10);
//    cout << "面积为:" << c1.S() << endl;
//    cout << "体积为:" << c1.V() << endl;
//    bool ret = compareCube(c1, c2);
//    if (ret)
//    {
//        cout << "c1和c2相等" << endl;
//    }
//    else
//    {
//        cout << "c1和c2不相等" << endl;
//    }
//     ret = c1.compare(c2);
//    if (ret)
//    {
//        cout << "成员函数判断c1和c2相等" << endl;
//    }
//    else
//    {
//        cout << "成员函数判断c1和c2不相等" << endl;
//    }
//    return 0;
//}



//点和圆关系案例
//#include<iostream>
//using namespace std;
////点类
//class Point
//{
//public:
//    //设置x、y
//    void setxy(int a, int b)
//    {
//        x = a;
//        y = b;
//    }
//    //获取x、y
//    int getx()
//    {
//        return x;
//    }
//    int gety()
//    {
//        return y;
//    }
//private:
//    int x;
//    int y;
//};
////圆类
//class Circle
//{
//public:
//    void setr(int a)//设置半径
//    {
//        m_r = a;
//    }
//    int getr()//获取半径
//    {
//        return m_r;
//    }
//    void setcenter(Point p)//设置圆心
//    {
//        m_center = p;
//    }
//    Point getcenter()//获取圆心
//    {
//        return m_center;
//    }
//private:
//    int m_r;//半径
//    Point m_center;//圆心
//};
//void panduan(Circle c,Point p)
//{
//    int distanced = (c.getcenter().getx() - p.getx()) * (c.getcenter().getx() - p.getx())
//        + (c.getcenter().gety() - p.gety()) * (c.getcenter().gety() - p.gety());//点到圆心距离的平方
//    int Rdistanced = c.getr() * c.getr();//半径的平方
//    if (distanced == Rdistanced)
//    {
//        cout << "点在圆上" << endl;
//    }
//    else if (distanced > Rdistanced)
//    {
//        cout << "点在圆外" << endl;
//    }
//    else
//    {
//        cout << "点在圆内" << endl;
//    }
//}
//int main()
//{
//    Circle c;
//    Point ce;//圆心
//    Point p;
//    ce.setxy(0, 0);
//    c.setcenter(ce);
//    c.setr(10);
//    p.setxy(10, 10);
//    panduan(c, p);
//        return 0;
//}

















//对象的构造和析构
                                                          
//构造函数进行初始化、析构函数进行清理
//构造和析构必须声明在全局作用域

/*
构造函数:
1.没有返回值，不用写void
2.函数名与类名相同
3.可以有参数，可以发生重载
4.构造函数由编译器自动调用一次(对象建立时调用)
*/
/*
析构函数:
1.没有返回值，不用写void
2.函数名为类名前加上~
3.不可以有参数，不可以发生重载
4.构造函数由编译器自动调用一次(对象释放时调用)
*/


//#include<iostream>
//using namespace std;
//class Person
//{
//public:
//    Person()
//    {
//        cout << "构造函数调用" << endl;
//    }
//    ~Person()
//    {
//        cout << "析构函数调用" << endl;
//    }
//};
//int main()
//{
//    Person p;
//    return 0;
//}




//构造函数的分类和调用
/*
按照参数分类:
1.无参构造(默认构造函数)
2.有参构造
按照类型分类:
1.普通构造函数
2.拷贝构造函数 
*/

/*
调用:
1.括号法
 不要使用括号发调用无参构造函数。编译器将认为代码是函数的声明
2.显示法:
不要使用拷贝构造函数初始化匿名对象
3.隐式类型转换法:
可读性较低
*/

//#include<iostream>
//using namespace std;
//class Person
//{
//public:
//    Person(int a)
//    {
//        cout << "构造函数调用" << endl;
//    }
//    Person(const Person& p)
//    {
//        cout << "拷贝构造函数调用" << endl;
//    }
//    ~Person()
//    {
//        cout << "析构函数调用" << endl;
//    }
//};
//int main()
//{
//    Person p(10);
//    Person p2(p);//括号法
//
//    Person p3 = Person(10);
//    Person p4 = Person(p3);//显示法 
//    //Person(10);//匿名对象——当前执行完成后，立即释放
//   
//    //隐式法
//    Person p5 = 10;//Person p5 = Person(10);
//    Person p6 = p5;//Peraon p6 = Person(p5);
//
//    cout << endl;
//    return 0;
//}







//拷贝构造函数的调用时机
/*
1.用已经创建好的对象来初始化新的对象
2.用值传递的方式给函数的参数传值(值传递的本质就是进行拷贝)
3.以值的方式返回局部对象
*/






//构造函数的调用规则
/*
1.编译器会给一个类默认添加四个函数(1)默认构造——空实现(2)析构函数——空实现(3)拷贝构造——值拷贝(4)operator=赋值运算符重载——值拷贝
2.若我们自己提供了有参构造函数，编译器就不会提供默认构造函数，但依然会提供拷贝构造函数
3.若我们提供了拷贝构造函数，编译器就不会提供其他构造函数
*/

//#include<iostream>
//using namespace std;
//class Person
//{
//public:
//    Person()
//    {
//        cout << "默认构造函数调用" << endl;
//    }
//    Person(int age)
//    {
//        m_Age = age;
//        cout << "有参构造函数调用" << endl;
//    }
//    //Person(const Person& p)//编译器默认添加拷贝构造函数，函数内值拷贝
//    //{
//    //    m_Age = p.m_Age;
//    //    cout << "拷贝构造函数调用" << endl;
//    //}
//    ~Person()
//    {
//        cout << "析构函数调用" << endl;
//    }
//    int m_Age =10;
//};
//int main()
//{
//    Person p1;
//    p1.m_Age = 18;
//    Person p2(p1);
//    cout << p2.m_Age << endl;//18
//    return 0;
//}


//#include<iostream>
//using namespace std;
//class A
//{
//public:
//    A() = default;//让编译器提供一个无参构造，效率比用户自行提供更高
//    //default只能修饰类默认添加的四个函数
//
//    A(int a)//提供了有参构造，不提供无参构造
//    {
//        cout << a << endl;
//    }
//
//    A(const A& a);//声明
//
//    A& operator=(const A& a) = delete;//用"=delete"修饰，此函数被禁用
//    //=delete可运用于各种成员函数
//};
//A::A(const A& a) = default;//可以放置到类的外部
//int main()
//{
//    A a;
//    A a2 = a;
//    a2 = a;//调用赋值运算重载函数,error
//    return 0;
//}









//深浅拷贝问题
//若有属性开辟在堆区，利用编译器提供的拷贝函数会调用浅拷贝带来的析构函数，产生重复释放堆区内存的问题
//利用深拷贝来解决浅拷贝问题(自己提供拷贝构造函数，实现深拷贝)
//#include<iostream>
//#include<cstdlib>
//using namespace std;
//class Person
//{
//public:
//    Person(const char* name, int age)
//    {
//        m_name = (char*)malloc(sizeof(name));
//        if (m_name == NULL)
//        {
//            return;
//        }
//        strcpy(m_name, name);
//        m_age = age;
//    }
//    Person(const Person& p)//自行提供深拷贝函数，否则容易因浅拷贝而二次释放空间
//    {
//        m_name = (char*)malloc(sizeof(p.m_name));
//        if (m_name == NULL)
//        {
//            return;
//        }
//        strcpy(m_name, p.m_name);
//        m_age = p.m_age;
//    }
//    char* m_name;
//    int m_age = 0;
//    ~Person()//结束时释放堆区空间
//    {
//        if (m_name != NULL)
//        {
//            free(m_name);
//            m_name = NULL;
//        }
//    }
//};
//int main()
//{
//    Person p("bjy", 18);
//    cout << "姓名:" << p.m_name << endl;
//    cout << "年龄:" << p.m_age << endl;
//    Person p2(p);//编译器提供了拷贝构造函数会造成二次释放空间
//    cout << "姓名:" << p.m_name << endl;
//    cout << "年龄:" << p.m_age << endl;
//    return 0;
//}










//初始化列表
//可以利用初始化列表，对类中属性进行初始化操作
//#include<iostream>
//using namespace std;
//class Person
//{
//public:
//    //1.
//    //Person() :m_a(10), m_b(20), m_c(30) {}//初始化列表 用于赋初值
//    //2.
//    Person(int a, int b, int c) :m_a(a), m_b(b), m_c(c) {}
//    int m_a;
//    int m_b;
//    int m_c;
//};
//int main()
//{
//    //1.
//    //Person p;
//    //2.
//    Person p(10, 20, 30);
//    cout << "m_a = " << p.m_a << endl;
//    cout << "m_b = " << p.m_b << endl;
//    cout << "m_c = " << p.m_c << endl;
//    return 0;
//}







//类对象做类中成员
//当其他类对象作为本类成员，先构造其他类对象，再构造自身。析构的顺序则相反。
/*
如下代码结果:
Phone的构造函数调用
Game的构造函数调用
Person的构造函数调用
Person的析构函数调用
Game的析构函数调用
Phone的析构函数调用
*/
//#include<iostream>
//#include<string>
//using namespace std;
//class Phone
//{
//public:
//    Phone(string name)
//    {
//        cout << "Phone的构造函数调用" << endl;
//        phonename = name;
//    }
//    string phonename;
//    ~Phone()
//    {
//        cout << "Phone的析构函数调用" << endl;
//    }
//};
//class Game
//{
//public:
//    Game(string gname)
//    {
//        cout << "Game的构造函数调用" << endl;
//        gamename = gname;
//    }
//    string gamename;
//    ~Game()
//    {
//        cout << "Game的析构函数调用" << endl;
//    }
//};
//class Person
//{
//public:
//    Person(string a, string b, string c) :m_name(a), m_phone(b), m_game(c)
//    {
//        cout << "Person的构造函数调用" << endl;
//    }
//    ~Person()
//    {
//        cout << "Person的析构函数调用" << endl;
//    }
//    string m_name;
//    Phone m_phone;
//    Game m_game;
//};
//int main()
//{
//    Person p("张三", "鸭梨", "王者");
//    return 0;
//}





//explicit关键字
/*
注意:
1.explicit用于修饰构造函数(位于构造函数前)，防止隐式转化(强制提高代码的可读性)
2.是针对单个参数的构造函数(或者除了第一个参数以外其余函数都有默认值的多参构造函数)而言
*/





//new创建对象
//delete释放对象及其堆区空间
/*
malloc和new的区别:
1.malloc和free属于库函数;new和delete属于运算符。
2.malloc不会调用构造函数，new会调用构造函数
3.malloc返回void*，需要强转;new返回创建的对象的指针
*/
/*
注意事项:
不要使用void*接收new出来的对象，什么类型的对象使用什么类型的指针接收
*/
//#include<iostream>
//using namespace std;
//class Person
//{
//public:
//    Person()
//    {
//        cout << "Person构造函数调用" << endl;
//    }
//    Person(int a)
//    {
//        cout << "Person有参构造函数调用" << endl;
//    }
//    ~Person()
//    {
//        cout << "Person析构函数调用" << endl;
//    }
//};
//int main()
//{
//    Person* p = new Person;//堆区开辟的内存需自己释放
//    delete p;
//
//    //利用new在堆区开辟数组，一定会调用默认构造函数
//    Person* pp = new Person[10];
//    delete[]pp;//加[]，告诉编译器寻找有几个对象
//
//    //在栈上开辟数组，可以没有默认构造函数
//    Person arr[2] = { Person(10) };
//    return 0;
//}












