
                                                           //数据的存储

                                                           //C语言类型

//1.内置类型(字节大小见书)
/*
char 字符数据类型
short 短整型
int 整型
long 长整型
long long 更长的整型
float 单精度浮点型
double 双精度浮点型
*/

//构造类型
/*
数组类型
结构体类型 struct
枚举类型 enum
联合类型 union
*/

//指针类型

//空类型
/*
void 表示空类型(无类型)
通常应用于函数的返回类型，函数的参数，指针类型
*/


//2.自定义类型







                                                         //原码、反码、补码

//无符号数原、反、补码相同
/*
计算机中的有符号数(整型)有三种表示方式
三种表示方式均有符号位和数值位两部分，符号位都是用0表示"正"，用1表示"负"
数值位三种表达式方法各不相同

正数原、反、补码相同，负数不同

原码：
    直接将数字按照正负数的形式翻译成二进制
反码：
    将原码的符号位不变，其他位依次按位取反得到
补码：
    将反码加上1得到
*/


/*
在计算机系统中，整型数值一律用补码来表示和存储
原因：
    使用补码，可以将符号位和数字域统一处理；
    同时，加法和减法也可以统一处理(CPU只有加法器)；
    此外，补码与反码相互转换，其运算过程是相同的，不需要额外的硬件电路
*/






                                                        //大小端
                                                        
//大端(存储)模式：(大端字节序存储模式)
//              是指数据的低位保存在内存的高地址中，而数据的高位保存在低地址中(眼见顺序)
//小端(存储)模式：(小端字节序存储模式)
//              是指数据的低位保存在内存的低地址中，而数据的高位保存在高地址中(眼见倒序)



//设计一个程序判段当前程序的字节序(判断第一个字节)
//#include<stdio.h>
//int check(void)
//{
//    int a = 1;
//    char* pa = (char*)&a;
//    return *pa;
//}
//int main()
//{
//    int ret;
//    ret=check();//返回1为小端，返回0为大端
//    if (ret == 1)
//    {
//        printf("小端\n");
//    }
//    else
//    {
//        printf("大端\n");
//    }
//    return 0;
//}








                                                 //浮点型在内存中的存储
//根据国际标准IEEE(电器和电子工程协会)754，任意一个二进制浮点数V可以表示成下面的形式
//(-1)^S*M*2^E(即用科学计数法表示)
//(-1)^S表示符号位。当S=0,V为正数；当S=1,为负数
//M表示有效数字，大于等于1，小于2
//2^E表示指数位

/*
例：
9.0
1001.0(二进制)
(-1)^0*1.001*2^3
*/



//IEEE 754规定：


//对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E,剩下的23位为有效数字M

//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数位E，剩下的52位为有效数字M

//M
//计算机内部保存M时，默认这个数的第一位总是为1，因此可以被舍去，只保存后面的小数部分，读取时再将第一位的1加上(节省一位有效数字，提高小数部分精度)

//E
/*

放入：
E为一个无符号整数。如果E为8位，它的取值范围为0-255；若E为11位，它的取值范围为0-2047。
但科学计数法中的E时可以出现负数的。
所以IEEE 754规定，存入内存时E的真实值必须加上一个中间值。对于8位的E,这个中间数为127；对于11位的E这个中间值为1023。
比如，2^10的E为10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001


取出：
1.E不为全0或不为全1
E减127(1023)得到E的真实值(即正常反向计算)

2.E全为0
这时，浮点数的指数E等于1-127(或者1-1023)即为真实值，有效数字不再加上第一位的1，而是还原为0.xxxx的小数。
这样是为了表示+/-0，以及接近于0的很小的数字

3.E全为1
这是，若M有效值的二进制全为0，表示+/-无穷大(正负取决于符号位)
*/























//%d以十进制形式输出带符号的整数(正数不输出符号)
//%u以十进制输出无符号整数 
//%o以八进制形式输出无符号整数(不输出前缀O)
//%x以十六进制输出无符号整数(不输出前缀OX)
//%c输出单个字符
//%s输出字符串
//%f浮点型—小数
//%f或%fl—双精度浮点型
//%e(或E)以指数形式输出单、双精度实数
//%g(或G)以%f%e中较短的输出宽度输出单、双精度实数
//%p以地址形式打印


